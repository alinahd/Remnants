<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Human Traces </title>
<style>
  body{
    margin:0;
    padding:0;
    overflow:hidden;
    background:#000;
    color:#fff;
    font-family:monospace;
}
  #canvas { 
    display:block;
    width:100vw;
    height:100vh; 
}
  .popup {
    position:absolute;
    left:50%;
    top:5%;
    transform:translateX(-50%);
    background: rgba(10,10,10,0.85); 
    padding:12px 16px;
    border-radius:8px;
    z-index:40;
    transition: opacity .5s ease, transform .4s ease;
}
  .popup.hidden {
    opacity:0; 
    transform:translateX(-50%) translateY(-8px); 
    pointer-events:none;
}
  .cig {
    position:absolute;
    right:20px;
    bottom:20px;
    z-index:50;
    display:flex;
    gap:10px;
    align-items:center;
    color:#ddd;
    font-size:12px;
}
  #button {
    width:60px;
    height:64px;
    padding:0;
    border:none;
    background:url(cig1.png);
    background-size:contain;
    background-position: center;
    cursor:pointer;
}
  #button.playing {
    transform:scale(.96);
    transition: transform .12s ease;
}

</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div class="popup" id="popup">Start drawing to leave a trace.</div>
<div class="cig" aria-hidden="true">
  <button id="button" title="Replay latest trace"></button>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const popup = document.getElementById('popup');
setTimeout(()=> popup.classList.add('hidden'), 4000);

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
const DPR = Math.min(2, devicePixelRatio || 1);
canvas.width = W * DPR;
canvas.height = H * DPR;
ctx.scale(DPR,DPR);

let strokes = [];
let currentStroke = null;
let mouseDown = false;
let lastPos = null;

const SAMPLE_DIST = 4;
const LINE_WIDTH = 8;
const NOISE = 1.3;

const LOCAL_COLOR = 'rgb(200,30,10)'; 
const OTHER_COLOR = '#5a2e17';       

canvas.addEventListener('mousedown', e=>{
  mouseDown = true;
  startStroke(e.clientX,e.clientY,'local');
});
canvas.addEventListener('mouseup', ()=>{
  mouseDown = false;
  currentStroke = null;
  lastPos = null;
});
canvas.addEventListener('mousemove', e=>{
  if(mouseDown && currentStroke) addPoint(e.clientX,e.clientY);
});


function timeStringNow(){ return new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); }

function startStroke(x,y,source){
  const ts = timeStringNow();
  currentStroke = { id: source+'-'+Date.now(), timeString: ts, points: [], source: source, color: source==='local'?LOCAL_COLOR:OTHER_COLOR };
  strokes.push(currentStroke);
  addPoint(x,y);
}

function addPoint(x,y){
  if(!currentStroke) return;
  const now = Date.now();
  if(lastPos && currentStroke.source==='local'){
    const dx = x - lastPos.x, dy = y - lastPos.y;
    if(Math.hypot(dx,dy)<SAMPLE_DIST) return;
  }
  const offsetX = (Math.random()-0.5)*NOISE*5;
  const offsetY = (Math.random()-0.5)*NOISE*5;
  currentStroke.points.push({x:x+offsetX, y:y+offsetY, originalX:x, originalY:y, createdAt: now});
  lastPos={x,y};
  if(currentStroke.source==='local') socket.emit('mouse',{x,y});
}

let otherTempStroke = null;
let otherIdle = null;

var socket = io.connect('http://localhost:3000');
socket.on('mouse', data=>{
  if(!otherTempStroke){
    otherTempStroke = { id:'other-'+Date.now(), timeString:timeStringNow(), points:[], source:'other', color:OTHER_COLOR };
    strokes.push(otherTempStroke);
  }
  const now = Date.now();
  const offsetX = (Math.random()-0.5)*NOISE*5;
  const offsetY = (Math.random()-0.5)*NOISE*5;
  otherTempStroke.points.push({x:data.x+offsetX,y:data.y+offsetY, originalX:data.x, originalY:data.y, createdAt:now});

  if(otherIdle) clearTimeout(otherIdle);
  otherIdle = setTimeout(()=>{ otherTempStroke=null; otherIdle=null; },250);
});

function drawBurnSegment(x,y,r){
  const grad = ctx.createRadialGradient(x,y,0,x,y,r*3);
  grad.addColorStop(0,"rgba(0,0,0,0.95)");
  grad.addColorStop(0.3,"rgba(30,10,0,0.8)");
  grad.addColorStop(0.55,"rgba(80,30,10,0.4)");
  grad.addColorStop(0.7,"rgba(140,60,20,0.2)");
  grad.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle=grad;
  ctx.beginPath();
  ctx.arc(x,y,r*3,0,Math.PI*2);
  ctx.fill();
}

function drawStroke(stroke){
  if(!stroke.points || stroke.points.length<1) return;

  const first = stroke.points[0];
  const now = Date.now();

  if(stroke.source==='local' || stroke.source==='other'){
    const fade = 1 - (now - first.createdAt)/3000;
    ctx.shadowBlur = 0;
    ctx.font = "12px monospace";
    const name = stroke.source==='local'?'you':'anonymous';
    ctx.fillStyle = `rgba(255,255,255,${fade})`;
    ctx.fillText(`${name} â€¢ ${stroke.timeString}`, first.x+12, first.y-10);
  }

  ctx.beginPath();
  ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
  for(let p of stroke.points.slice(1)) ctx.lineTo(p.x,p.y);

  ctx.strokeStyle = stroke.color;
  ctx.lineWidth = LINE_WIDTH + Math.random()*1.5;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.shadowBlur = stroke.source==='local'?10:0;
  ctx.shadowColor = stroke.source==='local'?"rgba(255,80,20,0.2)":"rgba(0,0,0,0)";
  ctx.stroke();

  for(let p of stroke.points) drawBurnSegment(p.x,p.y,6+Math.random()*2);
}

function draw(){
  ctx.globalCompositeOperation="source-over";
  ctx.fillStyle="rgba(0,0,0,0.03)";
  ctx.fillRect(0,0,W,H);
  ctx.globalCompositeOperation="lighter";
  for(const s of strokes) drawStroke(s);
  ctx.globalCompositeOperation="source-over";
  requestAnimationFrame(draw);
}
draw();

function scheduleReplay(stroke){
  if(!stroke || !stroke.points || stroke.points.length<1) return;
  const idx = strokes.findIndex(s=>s.id===stroke.id);
  if(idx!==-1) strokes.splice(idx,1); 

  const replay = { id:'replay-'+Date.now(), timeString:stroke.timeString, points:[], source:'replay', color:stroke.color };
  strokes.push(replay);

  const pts = stroke.points;
  let theDelay = 0;
  for(let i=1;i<pts.length;i++){
    const a=pts[i-1], b=pts[i];
    const segDur = Math.max(8,b.createdAt - a.createdAt);
    const dx = (b.originalX||b.x)-(a.originalX||a.x);
    const dy = (b.originalY||b.y)-(a.originalY||a.y);
    const steps = Math.max(1, Math.min(20, Math.floor(Math.hypot(dx,dy)/2)));
    for(let step=1;step<=steps;step++){
      const t = step/steps;
      const ix=(a.originalX||a.x)+dx*t;
      const iy=(a.originalY||a.y)+dy*t;
      const delay = theDelay + Math.round(segDur*(step/steps));
      setTimeout(((x,y)=>()=>{ replay.points.push({x,y,originalX:x,originalY:y,createdAt:Date.now()}); })(ix,iy), delay);
    }
    theDelay += segDur;
  }
  setTimeout(()=>{
    const ridx = strokes.findIndex(s=>s.id===replay.id);
    if(ridx!==-1) strokes.splice(ridx,1);
  }, theDelay+1200);
}

document.getElementById('button').addEventListener('click',()=>{
  if(!strokes.length) return;
  const last=strokes[strokes.length-1];
  if(!last) return;
  const btn=document.getElementById('button');
  btn.classList.add('playing');
  setTimeout(()=>btn.classList.remove('playing'),160);
  scheduleReplay(last);
});
</script>
</body>
</html>
